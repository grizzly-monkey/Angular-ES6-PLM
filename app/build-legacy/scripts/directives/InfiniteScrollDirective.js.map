{"version":3,"sources":["../../../scripts/directives/InfiniteScrollDirective.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4Bb,MAAM,CAAC,SAAS,CAAC,gBAAgB,EAAE,UAAU,OAAO,EAAE;AACrD,QAAO;AACN,UAAQ,EAAE,GAAG;AACb,OAAK,EAAE;AACN,UAAO,EAAE,UAAU;AACnB,SAAM,EAAE,GAAG;AACX,yBAAsB,EAAE,GAAG;GAC3B;AACD,MAAI,EAAE,cAAU,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE;AACtC,OAAI,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;;;;;;AAM7B,OAAI,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;AACrB,OAAI,IAAI,GAAG,OAAO,CAAC;;;;;;;;AAQnB,OAAI,YAAY,GAAG,sBAAU,GAAG,EAAE;AACjC,WAAQ,GAAG,CAAC,SAAS,GAAG,GAAG,CAAC,YAAY,IAAI,GAAG,CAAC,YAAY,CAAE;IAC9D,CAAC;;;;;AAKF,OAAI,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;AACrC,OAAG,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACvB,QAAI,GAAG,KAAK,CAAC,OAAO,CAAC;;;;;;;;AAQrB,gBAAY,GAAG,UAAU,GAAG,EAAE;AAC7B,YAAQ,GAAG,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,IAAI,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAE;KAC7F,CAAC;IACF;;;;;;;;AAQD,OAAI,aAAa,GAAG,SAAhB,aAAa,GAAe;AAC/B,QAAI,eAAe,GAAI,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,sBAAsB,CAAC,IAAI,KAAK,CAAC,sBAAsB,KAAK,KAAK,AAAC,CAAC;AACpH,QAAI,eAAe,KAAK,IAAI,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;AAClD,YAAO,EAAE,CAAC;KACV;IACD,CAAC;;;;;AAKF,OAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC;;AAEnC,QAAK,CAAC,GAAG,CAAC,UAAU,EAAE,YAAY;AACjC,QAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC,CAAC;GACH;EACD,CAAC;CACF,CAAC,CAAC","file":"InfiniteScrollDirective.js","sourcesContent":["'use strict';\n\n/**\n * @ngdoc directive\n * @name Directives.infiniteScroll\n * @restrict A\n *\n * @description This directive handles infinite scrolling\n * It expects the following attributes/parameters:\n * ####- update: a function to be called on scroll to the end of current list\n * ####- context: an optional parameter bounding the scroll event.  if this is not set, the scroll even will be binded to the element, if this is set, assume the context is window\n * ####- infiniteScrollDisabled: an optional parameter that can be used to conditionally disable infinite scroll.\n *\n * ##Dependencies\n *\n * @example\n * <doc:example>\n *   <doc:source>\n * \t\t<div infinite-scroll=\"\" update=\"doScroll\" context=\"window\"/>\n *   </doc:source>\n * </doc:example>\n *\n * TODO: should also add logic to detect scrolling up. Ideally, when infinite scrolling is used the client will only have a snapshot of the whole data.\n * For example, if we have 10000 records, and used is scrolling down and we are keep adding a batch of 100 records on scroll down. Ideally, the user\n * of the infinite scroll also removed some of the records when moving down. Therefore, we need to add logic to tell the user of the infinite scroll\n * that user is scrolling up (as they might need to fetch data from server again). There is a ticket for it  https://jira.autodesk.com/browse/PLM-2219.\n */\n/* global plm360 */\nplm360.directive('infiniteScroll', function ($window) {\n\treturn {\n\t\trestrict: 'A',\n\t\tscope: {\n\t\t\tcontext: '=context', // optional\n\t\t\tupdate: '&',\n\t\t\tinfiniteScrollDisabled: '='\n\t\t},\n\t\tlink: function (scope, element, attrs) {\n\t\t\tvar handler = scope.update();\n\n\t\t\t/**\n\t\t\t* set up condition test for scroll\n\t\t\t* by default we use the current element for scroll binding\n\t\t\t*/\n\t\t\tvar raw = element[0];\n\t\t\tvar elem = element;\n\n\t\t\t/**\n\t\t\t * @ngdoc method\n\t\t\t * @name Directives.infiniteScroll#conditionMet\n\t\t\t * @methodOf Directives.infiniteScroll\n\t\t\t * @description A private helper method that tests for scroll\n\t\t\t */\n\t\t\tvar conditionMet = function (raw) {\n\t\t\t\treturn (raw.scrollTop + raw.offsetHeight >= raw.scrollHeight);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t* if context is set, we assume it's window and we'll use it for scroll binding\n\t\t\t*/\n\t\t\tif (angular.isDefined(scope.context)) {\n\t\t\t\traw = scope.context[0];\n\t\t\t\telem = scope.context;\n\n\t\t\t\t/**\n\t\t\t\t * @ngdoc method\n\t\t\t\t * @name Directives.infiniteScroll#conditionMet\n\t\t\t\t * @methodOf Directives.infiniteScroll\n\t\t\t\t * @description A private helper method that tests for scroll with context\n\t\t\t\t */\n\t\t\t\tconditionMet = function (raw) {\n\t\t\t\t\treturn (raw.innerHeight + raw.pageYOffset >= angular.element(document)[0].body.scrollHeight);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @ngdoc method\n\t\t\t * @name Directives.infiniteScroll#scrollHandler\n\t\t\t * @methodOf Directives.infiniteScroll\n\t\t\t * @description A private helper method to check for infinite scroll condition.\n\t\t\t */\n\t\t\tvar scrollHandler = function () {\n\t\t\t\tvar isScrollEnabled = (angular.isUndefined(scope.infiniteScrollDisabled) || scope.infiniteScrollDisabled === false);\n\t\t\t\tif (isScrollEnabled === true && conditionMet(raw)) {\n\t\t\t\t\thandler();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t* now bind the scroll\n\t\t\t*/\n\t\t\telem.bind('scroll', scrollHandler);\n\n\t\t\tscope.$on('$destroy', function () {\n\t\t\t\telem.unbind('scroll');\n\t\t\t});\n\t\t}\n\t};\n});\n"]}